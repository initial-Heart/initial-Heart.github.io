{"meta":{"title":"Initial-Heart","subtitle":null,"description":"最难不过坚持！","author":"Jungle","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2022-04-14T08:56:38.000Z","updated":"2022-04-14T08:58:48.492Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"home","date":"2022-04-14T09:41:27.000Z","updated":"2022-04-14T09:41:27.225Z","comments":true,"path":"home/index.html","permalink":"http://example.com/home/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-04-13T12:02:20.000Z","updated":"2022-04-14T08:59:21.984Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-04-13T12:02:39.000Z","updated":"2022-04-14T09:07:26.560Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":"123"}],"posts":[{"title":"多态-1","slug":"多态-1","date":"2022-04-19T08:03:21.000Z","updated":"2022-04-24T08:19:49.351Z","comments":true,"path":"2022/04/19/多态-1/","link":"","permalink":"http://example.com/2022/04/19/%E5%A4%9A%E6%80%81-1/","excerpt":"多态多态概述同一个对象，在不同时刻表现出的不同形态。 多态的前提和体现 1.有继承&#x2F;实现关系 2.有方法重写 3.有父类引用指向子类对象","text":"多态多态概述同一个对象，在不同时刻表现出的不同形态。 多态的前提和体现 1.有继承&#x2F;实现关系 2.有方法重写 3.有父类引用指向子类对象 举例： 新建一个Animal类，有age，eat方法 1234public int age =40;public void eat()&#123; System.out.println(&quot;动物吃东西！&quot;);&#125; 新建一个Cat类继承Animal类，其中有age ,weight，eat方法 1234567public int age =30;public int weight=70;@Overridepublic void eat()&#123; //2.方法重写 System.out.println(&quot;猫吃东西!&quot;);&#125; 然后main 1234567 //3.父类引用指向子类对象 Aniaml a=new Cat(); System.out.println(a.age); //输出40 System.out.println(a.weigth); //报错 a.eat(); //输出猫吃东西!&#125; 12`40``猫吃东西!` 由此可见，编译的时候是看左面即父类中有无这个成员或方法，当方法重写之后则是输出重写之后的内容，没有被重写的还是父类中的内容。 多态的好处与弊端好处：提高了程序的扩展性 具体体现：定义方法的时候，使用父类型作为参数，将来在使用的时候，使用具体的子类型参与操作。 弊端：不能使用子类的特有功能 多态的转型：（实现子类的特有功能）向上转型： ​ 从子到父 ​ 父类引用指向子类对象 向下转型： ​ 从父到子 ​ 父类引用转为子类对象 向上转型： Aniaml a=new Cat();结合上面例子，给cat类加一个Jump方法，那么a.Jump将无法被调用 此时向下转型，Cat c = (Cat )a;将a有父类的对象强转为子类对象，此时就可以调用a.Jump。 抽象类概述：一个没有方法体的方法应该被定义为抽象方法，而类中如果有抽象方法，该类必须定义为抽象类 抽象类的特点 1.抽象类和抽象方法必须使用abstract关键字修饰 123 public abstract class 类名&#123;&#125;​ public abstract void eat（）； 2.抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类 3.抽象类不能实例化。 ​ 如何实例化？参照多态的方式，通过子类对象实例化，叫抽象类多态 4.抽象类的子类 ​ 要么重写抽象类中的所有的抽象方法 ​ 要么是抽象类 抽象类的成员特点 1.成员变量：可以是常量，也可以是变量 2.构造方法：有构造方法，但是不能实例化，用于子类访问父类数据的初始化 3.成员方法：可以抽象方法（限定子类必须完成某些动作），也可以是非抽象方法（提高代码复用性） 接口接口就是一种公共的规范标准，只要符合规范标准，大家都可以通用 java中的接口更多体现在对行为的抽象 接口特点 1.接口用关键字interface修饰 1public interface 接口名&#123;&#125; 2.类实现接口用implements表示 1public class 类名 implements 接口名&#123;&#125; 3.接口不能实例化 ​ 接口如何实例化？参照多态的方式，通过对类对象实例化，这叫接口多态。 ​ 多态的形式：具体类多态，抽象类多态，接口多态。 ​ 多态的前提：有继承或者实现关系；方法重写；父（类&#x2F;接口）引用指向（子&#x2F;实现）类对象 4.接口的实现类 ​ 要么重写接口中的所有抽象方法 ​ 要么是抽象类 接口的成员特点（常量，抽象方法） 1.成员变量 ​ 只能是常量 ​ 默认修饰符：public static final 2.构造方法 ​ 接口没有构造方法，因为接口主要是对行为进行抽象的，是没有具体存在的 ​ 一个类如果没有父类，默认继承自Object类 3.成员方法 ​ 只能是抽象方法 ​ 默认修饰符：public abstract 类和接口的关系类和类的关系 ​ 继承关系，只能单继承，但是可以多层继承 类和接口的关系 ​ 实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口 接口和接口的关系 ​ 继承关系，可以单继承，也可以多继承 形参和返回值类名作为形参和返回值​ 方法的形参是类名，其实需要的是该类的对象 ​ 方法的返回值是类名，其实返回的是该类的对象 抽象类名作为形参和返回值​ 方法的形参是抽象类名，其实需要的是该抽象类的子类对象 ​ 方法的返回值是抽象类名，其实返回的是该抽象类的子类对象 接口名作为形参和返回值​ 方法的形参是接口名，其实需要的是该接口的实现类对象 ​ 方法的返回值是接口名，其实返回的是该接口的实现类对象","categories":[{"name":"学习","slug":"学习","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"多态","slug":"多态","permalink":"http://example.com/tags/%E5%A4%9A%E6%80%81/"}]},{"title":"JiCheng-1","slug":"JiCheng-1","date":"2022-04-14T02:00:49.000Z","updated":"2022-04-14T14:59:15.666Z","comments":true,"path":"2022/04/14/JiCheng-1/","link":"","permalink":"http://example.com/2022/04/14/JiCheng-1/","excerpt":"继承什么是继承？多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。 多个类可以称为子类，单独这个类称为父类、超类或者基类。 子类可以直接访问父类中的非私有的属性和行为。 通过 extends 关键字让类与类之间产生继承关系。 1class Zi extends Fu&#123;&#125; //Zi是子类，Fu是父类","text":"继承什么是继承？多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。 多个类可以称为子类，单独这个类称为父类、超类或者基类。 子类可以直接访问父类中的非私有的属性和行为。 通过 extends 关键字让类与类之间产生继承关系。 1class Zi extends Fu&#123;&#125; //Zi是子类，Fu是父类 继承的特点*1.Java只支持单继承，不支持多继承 123//一个类只能有一个父类，不可以有多个父类。class SubDemo extends Demo&#123;&#125; //okclass SubDemo extends Demo1,Demo2...//error 2.Java支持多层（重）继承(继承体系)。 123class A&#123;&#125;class B extends A&#123;&#125;class C extends B&#123;&#125; super和this有什么区别?*super*是一个关键字，代表父类的存储空间标识。(可以理解为父亲的引用) super和this的用法相似。 this代表对象的引用(谁调用就代表谁)； super代表当前子类对父类的引用。 使用场景 当子父类出现同名成员时，可以用super进行区分； 子类要调用父类构造函数时，可以使用super语句。 区别 1.成员变量 12this.变量 -- 本类的super.变量 -- 父类的 123456public void show&#123; //访问本类中的成员变量age sout(this.age); //访问父类中的成员变量age sout(super.age);&#125; 2.构造方法 12this(...) -- 本类的super(...) -- 父类的 3.成员方法 12this.方法名() -- 本类的 super.方法名() -- 父类的 super();和this();都是在构造函数的第一行，不能同时出现。 什么时候使用继承？继承体现的关系： is a 举例：苹果和水果，猫和动物 继承中变量的访问特点在子类方法中访问一个变量： 局部范围&gt;成员范围&gt;父类 继承中构造方法的访问特点子类中所有的构造方法默认都会访问父类中的无参的构造方法： ○子类会继承父类中的数据，可能还会使用父类的数据，所以子类初始化之前，一定要先对父类初始化 ○每一个子类构造方法的第一条语句默认都是：super() 如果父类中没有无参构造方法，只有带参构造方法，该怎么办？ ○通过使用super关键字去显示的调用父类中的带参构造方法 ○在父类中自己主动写一个无参构造方法","categories":[{"name":"学习","slug":"学习","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"继承","slug":"继承","permalink":"http://example.com/tags/%E7%BB%A7%E6%89%BF/"}]},{"title":"Java-ArrayList应用","slug":"Java-ArrayList应用","date":"2022-04-13T09:01:28.000Z","updated":"2022-04-14T08:20:45.030Z","comments":true,"path":"2022/04/13/Java-ArrayList应用/","link":"","permalink":"http://example.com/2022/04/13/Java-ArrayList%E5%BA%94%E7%94%A8/","excerpt":"ArrayList详细介绍 学生管理系统","text":"ArrayList详细介绍 学生管理系统 建立一个Student的类，再类中加入姓名，性别，学号…..信息，同时加入构造函数 123private String name;private int age;private String num; 新建一个集合，Student类型的集合： 1ArrayList&lt;Student&gt; arr = new ArrayList&lt;&gt;(); 项目演示12345678910111213----------欢迎来到学生管理系统--------------1 添加学生2 删除学生3 修改学生4 查看所有学生5 退出请输出你的选择： 该页面代码： 123456789101112131415161718192021222324while (n != 5) &#123; System.out.println(&quot;---------欢迎来到学生管理系统---------&quot;); System.out.println(&quot;1 添加学生&quot;); System.out.println(&quot;2 删除学生&quot;); System.out.println(&quot;3 修改学生&quot;); System.out.println(&quot;4 查看所有学生&quot;); System.out.println(&quot;5 退出&quot;); System.out.println(&quot;请输入你的选择：&quot;); n = sc.nextInt(); if (n == 1) &#123; addStudent(arr); &#125; else if (n == 2) &#123; deleteStudent(arr); &#125; else if (n == 3) &#123; changeStudent(arr); &#125; else if (n == 4) &#123; checkStudent(arr); &#125; else if (n == 5) &#123; System.out.println(&quot;再见！&quot;); break; &#125; else &#123; System.out.println(&quot;请重新输入选择！&quot;); &#125; &#125; 添加学生的方法：12345public static void addStudent(ArrayList&lt;Student&gt; arr) &#123; //录入学生信息 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入学生学号：&quot;); String num = sc.nextLine(); 为了避免输出重复的学号，对学号进行一个判断，重复则添加失败 12345678//判断是否学号重复for (int i = 0; i &lt; arr.size(); i++) &#123; Student s = arr.get(i); if (num.equals(s.getNum())) &#123; System.out.println(&quot;学号重复，添加失败！&quot;); return; &#125;&#125; 123456789101112131415System.out.println(&quot;请输入学生姓名：&quot;); String name = sc.nextLine(); System.out.println(&quot;请输入学生年龄：&quot;); int age = sc.nextInt();​ //创建学生对象​ Student s = new Student();​ s.setAge(age);​ s.setNum(num);​ s.setName(name);​ ​ //放到集合中​ arr.add(s);​ System.out.println(&quot;添加完成！&quot;);​ &#125; 删除学生方法注意判断，在删除前先进行有无信息的判断 1234if (arr.size() == 0) &#123; System.out.println(&quot;无信息，请先添加再删除！&quot;); return;&#125; 12345678910111213141516171819public static void deleteStudent(ArrayList&lt;Student&gt; arr) &#123; //先判断集合中是否有信息 if (arr.size() == 0) &#123; System.out.println(&quot;无信息，请先添加再删除！&quot;); return; &#125; System.out.println(&quot;请输入要删除的学生的学号：&quot;); Scanner sc = new Scanner(System.in); String num = sc.nextLine(); for (int i = 0; i &lt; arr.size(); i++) &#123; Student s = arr.get(i); if (num.equals(s.getNum())) &#123; arr.remove(i); System.out.println(&quot;删除成功！&quot;); return; &#125; &#125; System.out.println(&quot;该信息不存在，删除失败！&quot;); &#125; 修改学生方法注意修改前的判断和修改时的判断 1234567891011121314151617181920212223242526272829public static void changeStudent(ArrayList&lt;Student&gt; arr) &#123; //先判断有无数据 if (arr.size() == 0) &#123; System.out.println(&quot;无信息，请先添加信息！&quot;); return; &#125; System.out.println(&quot;请输入要修改的学生的学号：&quot;); Scanner sc = new Scanner(System.in); String num = sc.nextLine(); for (int i = 0; i &lt; arr.size(); i++) &#123; Student s = arr.get(i); if (num.equals(s.getNum())) &#123; System.out.println(&quot;请输入新的学生姓名：&quot;); String name = sc.nextLine(); System.out.println(&quot;请输入新的学生的年龄：&quot;); int age = sc.nextInt(); s.setName(name); s.setAge(age); System.out.println(&quot;修改成功！&quot;); return; &#125; &#125; System.out.println(&quot;该信息不存在，修改失败&quot;); &#125; 查看所有学生的方法12345678910//判断集合中是否有数据 if (arr.size() == 0) &#123; System.out.println(&quot;无信息，请先添加信息！&quot;); return; //为了让程序不再执行 &#125; System.out.println(&quot;学号\\t\\t姓名\\t\\t年龄&quot;); for (int i = 0; i &lt; arr.size(); i++) &#123; Student s = arr.get(i); System.out.println(s.getNum() + &quot;\\t\\t&quot; + s.getName() + &quot;\\t\\t&quot; + s.getAge()); &#125; Student.java1234567891011121314151617181920212223242526272829303132333435package ArrayList.Test01;public class Student &#123; private String name; private int age; private String num; public Student() &#123; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void setNum(String num) &#123; this.num = num; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; public String getNum() &#123; return num; &#125;&#125;","categories":[{"name":"学习","slug":"学习","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"ArralList","slug":"ArralList","permalink":"http://example.com/tags/ArralList/"},{"name":"方法","slug":"方法","permalink":"http://example.com/tags/%E6%96%B9%E6%B3%95/"}]}],"categories":[{"name":"学习","slug":"学习","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"多态","slug":"多态","permalink":"http://example.com/tags/%E5%A4%9A%E6%80%81/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"继承","slug":"继承","permalink":"http://example.com/tags/%E7%BB%A7%E6%89%BF/"},{"name":"ArralList","slug":"ArralList","permalink":"http://example.com/tags/ArralList/"},{"name":"方法","slug":"方法","permalink":"http://example.com/tags/%E6%96%B9%E6%B3%95/"}]}